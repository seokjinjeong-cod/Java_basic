# Java_basic
## **객체지향언어**
**객체 지향 프로그래밍에서 사용하는 언어이며,**

**객체를 생성하고 조작하며 객체끼리 관계를 맺음으로써 여러 객체가 함께 수행될 수 있게 한다.**
___

### 키워드
- **객체** : 객체 지향 프로그램의 대상, 생성된 인스턴스  

- **클래스** : 객체를 프로그래밍하기 위해 코드로 만든 상태  

- **인스턴스** : 클래스가 메모리에 생성된 상태  

- **멤버 변수** : 클래스의 속성, 특성  

- **메서드** : 멤버 변수를 이용하여 클래스의 기능을 구현  

- **참조 변수** : 메모리에 생성된 인스턴스를 가리키는 변수  

- **참조 값** : 생성된 인스턴스의 메모리 주소 값  
___
### static 메서드
- static 변수를 위한 기능을 제공하는 static 메서드

- static 메서드에서는 인스턴스 변수를 사용할 수 없음

- 클래스 이름으로 참조하여 사용하는 메서드

- 클래스 메서드, 정적 메서드라고도 함  
___
### 상속
- 새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속받아서 속성이나 기능이 확장되는 클래스를 구현함

- 상위 클래스는 하위 클래스보다 일반적인 개념과 기능을 가짐

- 하위 클래스는 상위 클래스보다 구체적인 개념과 기능을 가짐

- extends 뒤에는 단 하나의  class만 사용할 수 있음
___
### 오버라이딩
- 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우

    하위 클래스에서 동일한 이름의 메서드를 재정의 할 수 있음
___
### 인터페이스의 요소
- 상수 : 선언된 모든 변수는 상수로 처리 됨

- 메서드 : 모든 메서드는 추상 메서드

- default 메서드 : 기본 구현을 가지는 메서드, 구현하는 클래스에서 재정의 할 수 있음

- static 메서드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메서드

- private 메서드 : 인터페이스 내에서 사용하기 위해 구현한 메서드, 구현하는 클래스에서 재정의 할 수 없음
___
### 인터페이스의 역할
- 인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 알려주는 명세 또는 약속

- 한 객체가 어떤 인터페이스의 타입이라 함은 그 인터페이스의 메서드를 구현했다는 의미

- 클라이언트 프로그램은 실제 구현내용을 몰라도 인터페이스의 정의만 알면 그 객체를 사용할 수 있음

- 인터페이스를 구현해 놓은 다양한 객체를 사용용함 - 다형성 : JDBC를 구현한 오라클, MSSQL 라이브러리등
___
### Object 클래스
- 모든 클래스의 최상위 클래스

- java.lang.Object클래스

- 모든 클래스는 Object클래스에서 상속 받음

- 모든 클래스는 Object클래스의 메서드를 사용할 수 있음

- 모든 클래스는 Object클래스의 일부 메서드를 재정의 하여 사용할 수 있음
___
### hashCode() 메서드
- hashCode() 메서드의 반환 값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환

- 두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?  

	논리적으로 동일 : equals()의 반환값이 true  
    
	동일할 hashCode() 값을 가짐 : hashCode()의 반환 값이 동일  
___
### clone() 메서드
- 객체의 복사본을 만듦

- 기본틀(prototype)으로 부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음

- 객체지향 프로그래밍의 정보은닉에 위배되는 가능성이 있으므로 복제할 객체는  

   cloneable 인터페이스를 명시해야 함
___
### Class 클래스
자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성됨

class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)가 포함되어 있음

class 클래스는 컴파일된 class파일에서 객체의 정보를 가져올 수 있음
___
### 제네릭 프로그래밍
- 변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형을 변환 될 수 있도록  
프로그래밍 하는 방식

- 실제 사용되는 참조 자료형으로의 변환은 컴파일러가 검증하므로 안정적인 프로그래밍 방식
___
### Collection 인터페이스
- 하나의 객체의 관리를 위해 선언된 인터페이스로 필요한 기본 메서드가 선언되어 있음

- 하위에 List, Set 인터페이스가 있음
___
### Map 인터페이스
- 쌍으로 이루어진 객체를 관리하는데 필요한 여러 메서드가 선언되어 있음

- Map을 사용하는 객체는 key-value 쌍으로 되어 있고 key는 중복될 수 없음
______
### List 인터페이스
- Collection 하위 인터페이스

- 객체를 순서에 따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스

- 배열의 기능을 구현하기 위한 메서드가 선언됨

- ArrayList, Vector, LinkedList
___
### Set 인터페이스
- Collection 하위의 인터페이스

- 중복을 허용하지 않음

- List는 순서기반의 인터페이스지만, Set은 순서가 없음

- get(i) 메서드가 제공되지 않음 (Iterator로 순회)

- 저장된 순서와 출력순서는 다를 수 있음

- 아이디, 주민번호, 사번 등 유일한 값이나 객체를 관리할 때 사용

- HashSet, TreeSet 클래스
___
### TreeSet 클래스
- 객체의 정렬에 사용되는 클래스

- 중복을 허용하지 않으면서 오름차순이나 내림차순으로 객체를 정렬함

- 내부적으로 이진 검색트리로 구현되어 있음

- 이진 검색 트리에 자료가 저장 될 때 비교하여 저장될 위치를 정함

- 객체 비교를 위해 Comparable이나 Comparator 인터페이스를 구현 해야함
___
### Comparable 인터페이스, Comparator 인터페이스
- 정렬 대상이 되는 클래스가 구현해야 하는 인터페이스

- Comparable은 compareTo() 메서드를 구현  
매개 변수와 객체 자신(this)를 비교

- Comparator은 compare() 메서드를 구현  
두개의 매개 변수를 비교  
TreeSet 생성자에 Comparator가 구현된 객체를 매개변수로 전달

- 일반적으로 Comparable을 더 많이 사용  
이미Comparable이 구현된 경우 Comparator을 이용해 다른 정렬 방식을 정의할 수 있음
___
### Map 인터페이스
- key-value pair의 객체를 관리하는데 필요한 메서드가 정의됨

- key는 중복 될 수 없음

- 검색을 위한 자료 구조

- key를 이용하여 값을 저장하거나 검색, 삭제 할때 사용하면 편리함

- 내부적으로 hash방식으로 구현 됨

- key가 되는 객체는 객체의 유일성함의 여부를 알기 위해 equals()와 hashCode() 메서드를 재정의 함
___
### HashMap 클래스
- Map 인터페이스를 구현한 클래스 중 가장 일반적으로 사용하는 클래스

- HashTable 클래스는 자바2 부터 제공된 클래스로 Vector 처럼 동기화를 제공 함

- pair 자료를 쉽고 빠르게 관리할 수 있음
___
### TreeMap 클래스
- key 객체를 정렬하여 key-value를 pair로 관리하는 클래스

- key에 사용되는 클래스에 Comparable, Comparator 인터페이스를 구현

- java에 많은 클래스들은 이미 Comparable이 구현되어 있음

- 구현 된 클래스를 key로 사용하는 경우는 구현할 필요 없음
___
### 내부 클래스
- 클래스 내부에 구현한 클래스(중첩된 클래스)

- 클래스 내부에서 사용하기 위해 선언하고 구현하는 클래스

- 주로 외부 클래스 생성자에서 내부 클래스를 생성
___
### 람다식
- 자바에서 함수형 프로그래밍을 구현하는 방식

- 클래스를 생성하지 않고 함수의 호출만으로 기능을 수행

- 함수형 인터페이스를 선언함
___
### 람다식 문법
- 매개 변수 하나인 경우 괄호 생략 가능 (두개인 경우는 괄호를 생략할 수 없음)  
str -> {System.out.println(str);}

- 중괄호 안의 구현부가 한 문장인 경우 중괄호 생략  
str -> System.out.println(str);

- 중괄호 안의 구현부가 한 문장이라도 return 문은 중괄호를 생략할 수 없음  
str -> return str.length();	// 오류

- 중괄호 안의 구현부가 반환문 하나라면 return과 중괄호를 모두 생략할 수  있음  
(x, y) -> x+y	// 두 값을 더하여 반환  
str -> str.length()	// 문자열 길이를 반환
___
### 함수형 프로그래밍
- 순수 함수를 구현하고 호출

- 매개변수만을 사용하도록 만든 함수로 외부 자료에 부수적인 영향이 발생하지 않도록 함

- 입력받은 자료를 기반으로 수행되고 외부에 영향을 미치지 않으므로 병렬처리등에 가능하고  
안정적인 확장성 있는 프로그래밍 방식
___
### 스트림
- 자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능(자료의 추상화)

- 배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리 가능

- 한번 생성하고 사용한 스트림은 재사용할 수 없음

- 스트림 연산은 기존 자료를 변경하지 않음

- 중간 연산과 최종 연산으로 구분 됨

- 최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산
___
### 오류와 예외 클래스
- 시스템 오류(error) : 가상 머신에서 발생, 프로그래머가 처리 할 수 없음

동적 메모리를 다 사용한 경우, stack over flow 등

- 예외(Exception) : 프로그램에서 제어 할 수 있는 오류

읽으려는 파일이 없는 경우, 네트워크나 소켓 연결 오류 등

- 자바 프로그램에서는 예외에 대한 처리를 수행 함

- try - catch문으로 예외 처리
```
try{	
	// 예외가 발생 할 수 있는 코드 부분	
} catch(처리할 예외 타입 e){
	// try블록 안에서 예외가 발생했을 때 수행되는 부분
} finally {
	// 예외 발생 여부와 상관 없이 항상 수행 되는 부분
	// 리소스를 정리하는 코드를 주로씀
}
```
### 예외 처리 미루기
- throws를 사용하여 예외처리 미루기

- try{} 블록으로 예외를 처리하지 않고, 메서드 선언부에 throws를 추가

- 예외가 발생한 메서드에서 예외 처리를 하지 않고 이 메서드를 호출한 곳에서 예외 처리를 한다는 의미

- main() 에서 throws를 사용하면 가상머신에서 처리 됨
___
### 입출력 스트림
- 입력 스트림 : 대상으로 부터 자료를 읽어 들이는 스트림

- 출력 스트림 : 대상으로 자료를 출력하는 스트림

- 바이트 단위 스트림 : 바이트 단위로 자료를 읽고 씀

- 문자 단위 스트림 : 문자는 2바이트씩 처리 해야 함

- 기반스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림

- 보조스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림

- 기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함함

___
### FileReader, FileWriter
- 파일에 문자를 읽고 쓸때 가장 많이 사용하는 클래스

- 문자 인코딩 방식을 지정할 수 있음
___
### 보조 스트림
- 실제 읽고쓰는 스트림이 아닌 보조적인 기능을 추가하는 스트림

- FilterInputStream과 FilterOutputStream이 보조스트림의 상위 클래스

- Buffered 스트림 : 내부에 8192 바이트 배열을 가지고 있음
읽거나 쓸 때 속도가 빠름

- DataInputStream/DataOutputStream : 자료가 저장된 상태 그대로 자료형을
유지하며 읽거나 쓰는 기능을 제공하는 스트림
___
### 직렬화(Serialization)
- 인스턴스의 상태를 그대로 저장하거나 네트웍으로 전송하고 이를 다시 복원(Deserialization)하는 방

- ObjectInputStream과 ObjectOutputStream사용

- 직렬화는 인스턴스의 내용이 외부(파일, 네트워크)로 유출되는 것이므로 프로그래머가 객체의 지렬화 가능 여부를 명시함

___
### 데코레이터 패턴(Decorator Pattern)
- 자바의 입출력 스트림은 데코레이터 패턴을 사용

- 실제 입출력 기능을 가진 객체(컴포넌트)와 그 외 다양한 기능을 제공하는  
데코레이터(보조스트림)을 사용하여 다양한 입출력 기능을 구현

- 상속보다 유연한 확장성을 가짐

- 지속적인 서비스의 증가와 제거가 용이함
___
### Thread
- Process

- 실행중인 프로그램

- OS로부터 메모리를 할당 받음

- 실제 프로그램이 수행되는 작업의 최소 단위

- 하나의 프로세스는 하나 이상의 Thread를 가지게 됨

- 자바Thread 클래스로 부터 상속받아 구현
___
### Runnable 인터페이스 구현
- 자바는 다중 상속이 허용되지 않으므로 이미 다른 클래스를 상속한 경우

- Thread를 만들려면 Runnable interface를 implements하도록 한다. 
___
### Multi-thread 프로그래밍
- 동시에 여러 개의 Thread가 수행되는 프로그래밍

- Thread는 각각의 작업공간(context)를 가짐

- 공유 자원이 있는 경우 race condition이 발생

- 임계 영역에 대한 동기화(synchronization)의 구현이 필요
___
### Thread 우선순위
- Thread.Min_PRIORITY(=1) ~ Thread.MAX_PRIORITY(=10)

- 디폴트 우선 순위 : Thread.NORM_PRIORITY(=5)
setPriority(int newPriority)  
int getPriority()
- 우선 순위가 높은 thread는 CPU를 배분 받을 확률이 높음
___
### join() 메서드
- 다른 thread의 결과를 보고 진행해야 하는 일이 있는 경우 join() 메서드를 활용

- join() 메서드를 호출한 thread가 non-runnable 상태가 됨
___
### interrupt() 메서드
- 다른 thread에 예외에 발생시킨 interrupt를 보냄

- thread가 join(), sleep(), wait() 메서드에 의해 블럭킹 되었다면  
interrupt에 의해 다시 runable 상태가 될 수 있음
___
### Thread 종료하기
- 데몬 등 무한 반복하는 thread가 종료될 수 있도록 run() 메서드 내의 while 문을 활용

- Thread.stop()은 사용하지 않음
___
### 임계 영역(critical section)
- 두개 이상의 thread가 동시에 접근하게 되는 리소스

- 임계 영역에 동시에 thread가 접근하게 되면 실행 결과를 보장할 수 없음

- thread간의 순서를 맞추는 동기화(synchronization)이 필요
___
### 동기화(Synchronization)
- 임계 영역에 여러 thread가 접근 하는 경우 한 thread가 수행 하는 동안 공유 자원을
lock하려 다른 thread의 접근을 막음

- 동기화를 잘못 구현하면 deadlock에 빠질 수 있음

- 자바에서 동기화 구현
synchronized 수행문과 synchronized 메서드를 이용

- synchronized 수행문
```
synchronized(참조형 수식) {

}	
참조형 수식에 해당되는 객체에 lock을 건다.
```
___
### synchronized 메서드
- 현재 이 메서드가 속해 있는 객체에 lock을 건다.

- synchronized 메서드 내에서 다른 synchronized 메서드를 호출하지 않는다.
(deadlock 방지위해)

- wait() : 리소스가 더 이상 유효하지 않은 경우 리소스가 사용 가능할 때 까지 위해 
thread를 non-runnable 상태로 전환

- wait() 상태가 된 thread는 notify()가 호출 될 때까지 기다린다.

- notify() : wait()하고 있는 thread 중 한 thread를 runnable 한 상태로 깨움

- notifyAll() : wait()하고 있는 모든 thread가 runnable 한 상태가 되도록 함

- notify()보다 notifyAll()을 사용하기를 권장

- 특정 thread가 통지를 받도록 제어 할 수 없으므로 모두 깨운 후 scheduler에 CPU를
점유하는 것이 좀 더 공평하다고 함
